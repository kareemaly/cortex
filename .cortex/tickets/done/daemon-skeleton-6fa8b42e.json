{
  "id": "6fa8b42e-5ed8-4eef-8e6a-518c1077b2ab",
  "title": "Daemon Skeleton",
  "body": "Set up the cortexd HTTP server with routing, middleware, configuration, and logging.\n\n## Context\n\nThe project foundation is complete. Now we need a running daemon that can serve HTTP requests.\n\nReference `~/projects/cortex/internal/daemon/` for patterns, but simplify per DESIGN.md (no SQLite, no git wrapper).\n\n## Requirements\n\n### 1. Dependencies\n\nAdd to go.mod:\n```\ngithub.com/go-chi/chi/v5\ngopkg.in/yaml.v3\ngopkg.in/natefinch/lumberjack.v2\n```\n\n### 2. cmd/cortexd/main.go\n\nExpand to full daemon entry point:\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/kareemaly/cortex1/internal/daemon/api\"\n\t\"github.com/kareemaly/cortex1/internal/daemon/config\"\n\t\"github.com/kareemaly/cortex1/internal/daemon/logging\"\n\t\"github.com/kareemaly/cortex1/pkg/version\"\n)\n\nfunc main() {\n\t// Load config\n\tcfg, err := config.Load()\n\tif err != nil {\n\t\tslog.Error(\"failed to load config\", \"error\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Setup logging\n\tlogger := logging.Setup(cfg.LogLevel)\n\tlogger.Info(\"starting cortexd\", \"version\", version.Version)\n\n\t// Create and start server\n\tsrv := api.NewServer(cfg, logger)\n\n\t// Graceful shutdown\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tsigCh := make(chan os.Signal, 1)\n\tsignal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\t<-sigCh\n\t\tlogger.Info(\"shutting down...\")\n\t\tcancel()\n\t}()\n\n\tif err := srv.Run(ctx); err != nil {\n\t\tlogger.Error(\"server error\", \"error\", err)\n\t\tos.Exit(1)\n\t}\n}\n```\n\n### 3. internal/daemon/config/config.go\n\nConfiguration loading from `~/.cortex/settings.yaml`:\n\n```go\npackage config\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"gopkg.in/yaml.v3\"\n)\n\ntype Config struct {\n\tPort     int    `yaml:\"port\"`\n\tLogLevel string `yaml:\"log_level\"`\n}\n\nfunc DefaultConfig() *Config {\n\treturn &Config{\n\t\tPort:     4200,\n\t\tLogLevel: \"info\",\n\t}\n}\n\nfunc Load() (*Config, error) {\n\tcfg := DefaultConfig()\n\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\treturn cfg, nil // Use defaults if can't find home\n\t}\n\n\tpath := filepath.Join(home, \".cortex\", \"settings.yaml\")\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn cfg, nil // Use defaults if no config file\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tif err := yaml.Unmarshal(data, cfg); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cfg, nil\n}\n```\n\n### 4. internal/daemon/logging/logging.go\n\nStructured logging setup:\n\n```go\npackage logging\n\nimport (\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"gopkg.in/natefinch/lumberjack.v2\"\n)\n\nfunc Setup(level string) *slog.Logger {\n\tvar logLevel slog.Level\n\tswitch level {\n\tcase \"debug\":\n\t\tlogLevel = slog.LevelDebug\n\tcase \"warn\":\n\t\tlogLevel = slog.LevelWarn\n\tcase \"error\":\n\t\tlogLevel = slog.LevelError\n\tdefault:\n\t\tlogLevel = slog.LevelInfo\n\t}\n\n\t// Log to file with rotation\n\thome, _ := os.UserHomeDir()\n\tlogPath := filepath.Join(home, \".cortex\", \"daemon.log\")\n\n\t// Ensure directory exists\n\tos.MkdirAll(filepath.Dir(logPath), 0755)\n\n\twriter := &lumberjack.Logger{\n\t\tFilename:   logPath,\n\t\tMaxSize:    10, // MB\n\t\tMaxBackups: 3,\n\t\tMaxAge:     7, // days\n\t}\n\n\thandler := slog.NewJSONHandler(writer, &slog.HandlerOptions{\n\t\tLevel: logLevel,\n\t})\n\n\treturn slog.New(handler)\n}\n```\n\n### 5. internal/daemon/api/server.go\n\nHTTP server with Chi router:\n\n```go\npackage api\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n\t\"github.com/kareemaly/cortex1/internal/daemon/config\"\n)\n\ntype Server struct {\n\tcfg    *config.Config\n\tlogger *slog.Logger\n\trouter *chi.Mux\n\tserver *http.Server\n}\n\nfunc NewServer(cfg *config.Config, logger *slog.Logger) *Server {\n\tr := chi.NewRouter()\n\n\t// Middleware\n\tr.Use(middleware.RequestID)\n\tr.Use(middleware.RealIP)\n\tr.Use(middleware.Recoverer)\n\tr.Use(requestLogger(logger))\n\n\ts := &Server{\n\t\tcfg:    cfg,\n\t\tlogger: logger,\n\t\trouter: r,\n\t}\n\n\ts.routes()\n\treturn s\n}\n\nfunc (s *Server) routes() {\n\ts.router.Get(\"/health\", s.handleHealth)\n}\n\nfunc (s *Server) Run(ctx context.Context) error {\n\ts.server = &http.Server{\n\t\tAddr:         fmt.Sprintf(\":%d\", s.cfg.Port),\n\t\tHandler:      s.router,\n\t\tReadTimeout:  10 * time.Second,\n\t\tWriteTimeout: 0, // Disabled for SSE\n\t\tIdleTimeout:  60 * time.Second,\n\t}\n\n\ts.logger.Info(\"server listening\", \"port\", s.cfg.Port)\n\n\terrCh := make(chan error, 1)\n\tgo func() {\n\t\terrCh <- s.server.ListenAndServe()\n\t}()\n\n\tselect {\n\tcase err := <-errCh:\n\t\tif err != http.ErrServerClosed {\n\t\t\treturn err\n\t\t}\n\tcase <-ctx.Done():\n\t\tshutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\t\tdefer cancel()\n\t\treturn s.server.Shutdown(shutdownCtx)\n\t}\n\n\treturn nil\n}\n```\n\n### 6. internal/daemon/api/middleware.go\n\nRequest logging middleware:\n\n```go\npackage api\n\nimport (\n\t\"log/slog\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/go-chi/chi/v5/middleware\"\n)\n\nfunc requestLogger(logger *slog.Logger) func(next http.Handler) http.Handler {\n\treturn func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tstart := time.Now()\n\t\t\tww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)\n\n\t\t\tdefer func() {\n\t\t\t\tlogger.Info(\"request\",\n\t\t\t\t\t\"method\", r.Method,\n\t\t\t\t\t\"path\", r.URL.Path,\n\t\t\t\t\t\"status\", ww.Status(),\n\t\t\t\t\t\"duration\", time.Since(start),\n\t\t\t\t\t\"request_id\", middleware.GetReqID(r.Context()),\n\t\t\t\t)\n\t\t\t}()\n\n\t\t\tnext.ServeHTTP(ww, r)\n\t\t})\n\t}\n}\n```\n\n### 7. internal/daemon/api/handlers.go\n\nHealth check handler:\n\n```go\npackage api\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"github.com/kareemaly/cortex1/pkg/version\"\n)\n\nfunc (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(map[string]any{\n\t\t\"status\":  \"ok\",\n\t\t\"version\": version.Version,\n\t})\n}\n```\n\n### 8. Remove .gitkeep files\n\nDelete these files as they're replaced by real code:\n- `internal/daemon/api/.gitkeep`\n- `internal/daemon/config/.gitkeep`\n\nKeep `internal/daemon/mcp/.gitkeep` (MCP ticket will handle it).\n\n## Verification\n\n```bash\n# Build succeeds\nmake build\n\n# Daemon starts and listens\n./bin/cortexd &\n# Should see: \"server listening\" in logs\n\n# Health check works\ncurl http://localhost:4200/health\n# Should return: {\"status\":\"ok\",\"version\":\"dev\"}\n\n# Graceful shutdown works\nkill %1\n# Should see: \"shutting down...\" in logs\n\n# Lint passes\nmake lint\n```\n\n## Notes\n\n- WriteTimeout is 0 to support SSE later\n- Config file is optional - daemon uses defaults if missing\n- Logs go to ~/.cortex/daemon.log with rotation\n- No business logic yet - just the HTTP skeleton\n\n## Implementation\n\n### Commits\n- `9e3403e` feat: add daemon HTTP server skeleton with Chi router and graceful shutdown\n\n### Key Files Changed\n- `cmd/cortexd/main.go` - Full daemon entry point with signal handling\n- `internal/daemon/config/config.go` - Config loading from ~/.cortex/settings.yaml\n- `internal/daemon/logging/logging.go` - slog JSON handler with lumberjack rotation\n- `internal/daemon/api/server.go` - Chi router with middleware stack\n- `internal/daemon/api/middleware.go` - Request logging middleware\n- `internal/daemon/api/handlers.go` - Health endpoint\n- `go.mod` / `go.sum` - Added chi/v5, yaml.v3, lumberjack.v2 dependencies\n\n### Decisions\n- Logs write to both stderr and file (multiwriter) for visibility during development\n- Health handler uses separate function instead of method on Server struct for simplicity\n- Error from json.Encode is handled to satisfy linter (errcheck)\n- Request logger logs duration in milliseconds rather than duration string",
  "dates": {
    "created": "2026-01-19T14:05:41Z",
    "updated": "2026-01-19T14:05:41Z",
    "done": "2026-01-19T14:05:41Z"
  },
  "comments": [],
  "session": null
}
